import json
import re
import os
import sys

# This magic line ensures Python can find your sandbox.py file in the parent folder!
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from sandbox import run_tests_in_docker
from langchain_core.messages import SystemMessage, HumanMessage
from .llm_config import llm
from .graph_state import AgentState

# ==========================================
# üèõÔ∏è PROMPTS
# ==========================================

CLASSIFIER_PROMPT = """
You are the "Minister of Classification" in an autonomous code-repair system.
Your ONLY job is to analyze error logs and categorize the bug into exactly one of the following categories:
- LINTING
- SYNTAX
- LOGIC
- TYPE_ERROR
- IMPORT
- INDENTATION

Rules:
1. You must respond with ONLY the category name. Nothing else. No explanation.
2. If the error log contains multiple issues, prioritize the most fundamental one that is likely causing the others.
3. If the logs indicate a test failure without a clear error message, classify it as LOGIC.
4. Do not hallucinate a category not in the list.

Examples:
Input: "IndentationError: expected an indented block" -> Output: INDENTATION
Input: "NameError: name 'pd' is not defined" -> Output: IMPORT
Input: "TypeError: unsupported operand type(s) for +: 'int' and 'str'" -> Output: TYPE_ERROR
"""

LOCALIZER_PROMPT = """
You are the "Minister of Localization" in an autonomous code-repair system.
Your ONLY job is to analyze the provided error log and extract the EXACT source code file path and line number where the underlying bug exists.

CRITICAL RULES - READ CAREFULLY:
1. NEVER target a test file! If the file is named 'test_*.py', '*_test.py', or is inside a 'tests/' folder, YOU MUST NOT RETURN IT.
2. THE ASSERTION TRAP: If the error is an AssertionError or test failure, the traceback will often stop at the test file (e.g., test_calculator.py). You must logically deduce the source file. If the test file is 'test_calculator.py', the source file is likely 'calculator.py'. 
3. If you cannot determine the exact line number in the source file, return line 0.
4. Respond ONLY with a valid JSON object. Do NOT include markdown code blocks.
5. The JSON must have exactly two keys: "file" and "line".

Example:
If test_calculator.py fails on line 7, output:
{"file": "calculator.py", "line": 0}
"""

REPAIR_PROMPT = """
You are the "Minister of Repair" in an autonomous code-repair system.
You will be provided with the Bug Type, Location, Error Log, and Current Code.

Your ONLY job is to fix the bug and return the complete, corrected code.

Rules:
1. Do NOT use JSON.
2. You MUST respond in this EXACT format:

COMMIT: [AI-AGENT] <short description of fix>
```python
<your complete fixed file code here>
"""
QA_PROMPT = """
You are the "Minister of Quality Assurance". 
Your job is to read a Python file and write a robust 'unittest' suite for it.

Rules:
1. Use the 'unittest' framework.
2. Ensure you import the functions correctly from the file.
3. Write at least 3-4 test cases covering edge cases.
4. Respond ONLY with the Python code inside a ```python ``` block.
"""

def minister_of_qa(state: AgentState) -> AgentState:
    """Generates a unit test file if the repo is empty of tests."""
    print("--- MINISTER OF QA: Generating Autonomous Test Suite ---")
    
    repo_path = state.get("repo_path")
    target_file = state.get("target_file")
    
    # If we don't know the file yet, we can't write tests
    if not target_file or target_file == "unknown":
        return {"test_generated": True}

    file_path = os.path.join(repo_path, target_file)
    with open(file_path, "r", encoding="utf-8") as f:
        code = f.read()

    messages = [
        SystemMessage(content=QA_PROMPT),
        HumanMessage(content=f"Write a test suite for this file: {target_file}\n\nCode:\n{code}")
    ]
    
    response = llm.invoke(messages)
    code_match = re.search(r'```python\n(.*?)\n```', response.content, re.DOTALL)
    test_code = code_match.group(1).strip() if code_match else ""

    if test_code:
        test_file_name = f"test_{target_file}"
        with open(os.path.join(repo_path, test_file_name), "w", encoding="utf-8") as f:
            f.write(test_code)
        print(f"‚úÖ QA: Created {test_file_name}")

    return {"test_generated": True, "error_message": "Tests generated by AI. Re-running discovery..."}
#==========================================
#üß† AGENT NODES (FUNCTIONS)
#==========================================
def minister_of_classification(state: AgentState) -> AgentState:
    """Analyzes the error logs and determines the bug type."""
    print("--- MINISTER OF CLASSIFICATION: Analyzing Errors ---")
    error_logs = state.get("error_message", "")

    messages = [
        SystemMessage(content=CLASSIFIER_PROMPT),
        HumanMessage(content=f"Here are the error logs from the sandbox:\n\n{error_logs}")
    ]

    response = llm.invoke(messages)
    bug_type = response.content.strip().upper()

    ALLOWED_TYPES = {"LINTING", "SYNTAX", "LOGIC", "TYPE_ERROR", "IMPORT", "INDENTATION"}
    if bug_type not in ALLOWED_TYPES:
        print(f"WARNING: LLM returned invalid bug type '{bug_type}'. Defaulting to LOGIC.")
        bug_type = "LOGIC"

    print(f"--- Bug Classified as: {bug_type} ---")
    return {"bug_type": bug_type}
def minister_of_localization(state: AgentState) -> AgentState:
    """Analyzes the error logs to pinpoint the exact file and line number."""
    print("--- MINISTER OF LOCALIZATION: Pinpointing Error Location ---")
    error_logs = state.get("error_message", "")

    messages = [
        SystemMessage(content=LOCALIZER_PROMPT),
        HumanMessage(content=f"Error Logs:\n\n{error_logs}")
    ]

    response = llm.invoke(messages)
    raw_output = response.content.strip()

    if raw_output.startswith("```json"):
        raw_output = raw_output.replace("```json", "").replace("```", "").strip()
        
    try:
        location_data = json.loads(raw_output)
        target_file = location_data.get("file", "unknown")
        target_line = int(location_data.get("line", 0))
        
        print(f"--- Location Found -> File: {target_file} | Line: {target_line} ---")
        return {"target_file": target_file, "target_line": target_line}
        
    except json.JSONDecodeError:
        print(f"WARNING: Minister of Localization hallucinated invalid JSON: {raw_output}")
        return {"target_file": "unknown", "target_line": 0}
def minister_of_repair(state: AgentState) -> AgentState:
    """Generates the actual code fix and the strict commit message."""
    print("--- MINISTER OF REPAIR: Forging the Fix ---")

    # 1. Find the real file inside the cloned sandbox folder
    full_path = os.path.join(state.get('repo_path', ''), state.get('target_file', 'unknown'))
    current_content = state.get('file_content', '')

    # If the file content isn't in memory yet, read it from the physical hard drive
    if not current_content and os.path.exists(full_path):
        with open(full_path, "r", encoding="utf-8") as f:
            current_content = f.read()

    context = f"""
    Bug Type: {state.get('bug_type', 'UNKNOWN')}
    Location: {state.get('target_file', 'unknown')} (Line {state.get('target_line', 0)})
    Error Log: {state.get('error_message', '')}
    Current File Content:
    {current_content}
    """

    messages = [
        SystemMessage(content=REPAIR_PROMPT),
        HumanMessage(content=context)
    ]

    response = llm.invoke(messages)
    raw_output = response.content.strip()

    # 2. Extract the Commit Message using Regex
    commit_match = re.search(r'COMMIT:\s*(.+)', raw_output)
    commit_msg = commit_match.group(1).strip() if commit_match else "[AI-AGENT] Attempted automated fix"

    # 3. Extract the Python Code using Regex (ignores markdown hallucinations)
    code_match = re.search(r'```python\n(.*?)\n```', raw_output, re.DOTALL)
    fixed_code = code_match.group(1).strip() if code_match else current_content

    print(f"--- Fix Generated! Commit: {commit_msg} ---")

    new_fix = {
        "file": state.get("target_file", "unknown"),
        "type": state.get("bug_type", "LOGIC"),
        "line": state.get("target_line", 0),
        "commitMsg": commit_msg,
        "status": "PENDING_VALIDATION"
    }

    return {
        "proposed_fix": fixed_code, 
        "fixes_applied": state.get("fixes_applied", []) + [new_fix]
    }
def minister_of_validation(state: AgentState) -> AgentState:
    """Checks if the generated fix matches the required formatting rules."""
    print("--- MINISTER OF VALIDATION: Inspecting the Fix ---")

    fixes = state.get("fixes_applied", [])
    if not fixes:
        print("--- Validation FAILED: No fix found. ---")
        return {"run_status": "FORMATTING_FAILED", "format_attempts": state.get("format_attempts", 0) + 1}
        
    latest_fix = fixes[-1]
    commit_msg = latest_fix.get("commitMsg", "")
    proposed_code = state.get("proposed_fix", "")

    # Rule 1: Commit message must start with [AI-AGENT]
    # Rule 2: Code must actually exist
    if commit_msg.startswith("[AI-AGENT]") and len(proposed_code.strip()) > 0:
        print("--- Validation PASSED: Format is pristine. ---")
        latest_fix["status"] = "VALIDATED"
        return {"run_status": "FORMAT_VALID", "fixes_applied": fixes}
    else:
        print(f"--- Validation FAILED: Commit message '{commit_msg}' violates rules. ---")
        latest_fix["status"] = "FAILED"
        return {"run_status": "FORMATTING_FAILED", "format_attempts": state.get("format_attempts", 0) + 1, "fixes_applied": fixes}
def execution_sandbox(state: AgentState) -> AgentState:
    """The True Agent Environment. Overwrites the file and runs tests dynamically in DOCKER."""
    print("--- ENVIRONMENT: Applying Fix and Booting Docker ---")
    
    full_file_path = os.path.join(state.get("repo_path", ""), state.get("target_file", ""))
    proposed_fix = state.get("proposed_fix", "")
    fixes = state.get("fixes_applied", [])

    try:
        # Overwrite the physical file in your local quarantine folder
        with open(full_file_path, "w", encoding="utf-8") as f:
            f.write(proposed_fix)
    except Exception as e:
        return {"run_status": "TESTS_FAILED", "retry_count": state.get("retry_count", 0) + 1}

    # üê≥ RUN TESTS IN DOCKER
    result = run_tests_in_docker(state.get("repo_path", ""))

    if result.get("passed", False):
        print("‚úÖ DOCKER ENVIRONMENT: Tests Passed! The bug is dead.")
        if fixes:
            fixes[-1]["status"] = "SUCCESS" # Triggers the green UI checkmark
        return {"run_status": "TESTS_PASSED", "fixes_applied": fixes}
    else:
        print("‚ùå DOCKER ENVIRONMENT: Tests Failed! Capturing new error logs...")
        if fixes:
            fixes[-1]["status"] = "FAILED" 
            
        return {
            "run_status": "TESTS_FAILED",
            "error_message": result.get("error_logs", "Unknown error occurred."), 
            "retry_count": state.get("retry_count", 0) + 1,
            "fixes_applied": fixes
        }